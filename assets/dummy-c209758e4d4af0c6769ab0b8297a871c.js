"use strict"
define("dummy/app",["exports","dummy/resolver","ember-load-initializers","dummy/config/environment"],function(e,t,n,o){Object.defineProperty(e,"__esModule",{value:!0})
var r=Ember.Application.extend({modulePrefix:o.default.modulePrefix,podModulePrefix:o.default.podModulePrefix,Resolver:t.default});(0,n.default)(r,o.default.modulePrefix),e.default=r}),define("dummy/components/key-down-counter",["exports","ember-keyboard"],function(e,t){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1
return function(t,n){Ember.get(this,"stopImmediatePropagation")&&n.stopImmediatePropagation(),Ember.get(this,"stopPropagation")&&n.stopPropagation(),this.incrementProperty("counter",e)}}Object.defineProperty(e,"__esModule",{value:!0}),e.default=Ember.Component.extend(t.EKMixin,{tagName:"span",classNames:"counter-container",toggleActivated:!0,hook:"counter",counter:0,keyboardActivated:Ember.computed("parentActivated","toggleActivated","activatedToggle",{get:function(){return(!this.get("activatedToggle")||this.get("toggleActivated"))&&this.get("parentActivated")}}).readOnly(),decrementCounter:Ember.on((0,t.keyDown)("ArrowLeft"),n(-1)),incrementCounter:Ember.on((0,t.keyDown)("ArrowRight"),n(1)),decrementCounter10:Ember.on((0,t.keyDown)("shift+ArrowLeft"),n(-10)),incrementCounter10:Ember.on((0,t.keyDown)("shift+ArrowRight"),n(10)),decrementCounter100:Ember.on((0,t.keyDown)("ctrl+shift+ArrowLeft"),n(-100)),incrementCounter100:Ember.on((0,t.keyDown)("ctrl+shift+ArrowRight"),n(100)),resetCounter:Ember.on((0,t.keyUp)("KeyR"),function(){this.set("counter",0)}),setCounterTo5:Ember.on((0,t.keyPress)("Digit5"),function(){this.set("counter",5)})})}),define("dummy/components/keyboard-activated-widget",["exports","dummy/mixins/enterable"],function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),e.default=Ember.Component.extend(t.default)}),define("dummy/components/keyboard-first-responder-widget",["exports","dummy/mixins/enterable"],function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),e.default=Ember.Component.extend(t.default)}),define("dummy/components/keyboard-lax-priority-widget",["exports","dummy/mixins/enterable"],function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),e.default=Ember.Component.extend(t.default)}),define("dummy/components/keyboard-priority-widget",["exports","dummy/mixins/enterable"],function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),e.default=Ember.Component.extend(t.default)}),define("dummy/components/keyboard-propagation-widget",["exports","dummy/mixins/enterable"],function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),e.default=Ember.Component.extend(t.default,{keyboard:Ember.inject.service(),_activate:function(){this._super.apply(this,arguments),Ember.set(this,"keyboard.isPropagationEnabled",!0)},deactivate:function(){this._super.apply(this,arguments),Ember.set(this,"keyboard.isPropagationEnabled",!1)}})}),define("dummy/components/mouse-down-counter",["exports","ember-keyboard"],function(e,t){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1
return function(t,n){Ember.get(this,"stopImmediatePropagation")&&n.stopImmediatePropagation(),Ember.get(this,"stopPropagation")&&n.stopPropagation(),this.incrementProperty("counter",e)}}Object.defineProperty(e,"__esModule",{value:!0}),e.default=Ember.Component.extend(t.EKMixin,{tagName:"span",classNames:"counter-container",toggleActivated:!0,hook:"mouse-down-counter",counter:0,keyboardActivated:Ember.computed("parentActivated","toggleActivated","activatedToggle",{get:function(){return(!this.get("activatedToggle")||this.get("toggleActivated"))&&this.get("parentActivated")}}).readOnly(),incrementCounterLeft:Ember.on((0,t.mouseDown)("left"),n(1)),incrementCounterRight:Ember.on((0,t.mouseDown)("right"),n(10)),incrementCounterMiddle:Ember.on((0,t.mouseDown)("middle"),n(-10))})}),define("dummy/components/touch-start-counter",["exports","ember-keyboard"],function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),e.default=Ember.Component.extend(t.EKMixin,{tagName:"span",classNames:"counter-container",toggleActivated:!0,hook:"touch-start-counter",counter:0,keyboardActivated:Ember.computed("parentActivated","toggleActivated","activatedToggle",{get:function(){return(!this.get("activatedToggle")||this.get("toggleActivated"))&&this.get("parentActivated")}}).readOnly(),incrementCounter:Ember.on((0,t.touchStart)(),function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1
return function(t,n){Ember.get(this,"stopImmediatePropagation")&&n.stopImmediatePropagation(),Ember.get(this,"stopPropagation")&&n.stopPropagation(),this.incrementProperty("counter",e)}}(1))})}),define("dummy/components/trigger-event-test",["exports","dummy/templates/components/trigger-event-test","ember-keyboard"],function(e,t,n){Object.defineProperty(e,"__esModule",{value:!0}),e.default=Ember.Component.extend(n.EKMixin,{layout:t.default,keyboardActivated:!0,keyDown:!1,keyDownWithMods:!1,keyPress:!1,keyUp:!1,onKeyDown:Ember.on((0,n.keyDown)("KeyA"),function(){this.toggleProperty("keyDown")}),onKeyDownWithMods:Ember.on((0,n.keyDown)("KeyA+cmd+shift"),function(){this.toggleProperty("keyDownWithMods")}),onKeyPress:Ember.on((0,n.keyPress)("KeyA"),function(){this.toggleProperty("keyPress")}),onKeyUp:Ember.on((0,n.keyUp)("KeyA"),function(){this.toggleProperty("keyUp")})})}),define("dummy/helpers/format-markdown",["exports","markdown-code-highlighting/helpers/format-markdown"],function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),e.default=t.default}),define("dummy/helpers/hook",["exports","ember-hook/helpers/hook"],function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),Object.defineProperty(e,"default",{enumerable:!0,get:function(){return t.default}}),Object.defineProperty(e,"hook",{enumerable:!0,get:function(){return t.hook}})}),define("dummy/initializers/container-debug-adapter",["exports","ember-resolver/resolvers/classic/container-debug-adapter"],function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),e.default={name:"container-debug-adapter",initialize:function(){var e=arguments[1]||arguments[0]
e.register("container-debug-adapter:main",t.default),e.inject("container-debug-adapter:main","namespace","application:main")}}}),define("dummy/initializers/ember-hook/initialize",["exports","ember-hook/initializers/ember-hook/initialize"],function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),Object.defineProperty(e,"default",{enumerable:!0,get:function(){return t.default}}),Object.defineProperty(e,"initialize",{enumerable:!0,get:function(){return t.initialize}})}),define("dummy/initializers/ember-keyboard-first-responder-inputs",["exports","ember-keyboard/initializers/ember-keyboard-first-responder-inputs"],function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),Object.defineProperty(e,"default",{enumerable:!0,get:function(){return t.default}}),Object.defineProperty(e,"initialize",{enumerable:!0,get:function(){return t.initialize}})}),define("dummy/initializers/export-application-global",["exports","dummy/config/environment"],function(e,t){function n(){var e=arguments[1]||arguments[0]
if(!1!==t.default.exportApplicationGlobal){var n
if("undefined"!=typeof window)n=window
else if("undefined"!=typeof global)n=global
else{if("undefined"==typeof self)return
n=self}var o,r=t.default.exportApplicationGlobal
o="string"==typeof r?r:Ember.String.classify(t.default.modulePrefix),n[o]||(n[o]=e,e.reopen({willDestroy:function(){this._super.apply(this,arguments),delete n[o]}}))}}Object.defineProperty(e,"__esModule",{value:!0}),e.initialize=n,e.default={name:"export-application-global",initialize:n}}),define("dummy/mixins/enterable",["exports"],function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.default=Ember.Mixin.create({classNames:["keyboard-widget"],classNameBindings:["keyboardActivated:active"],widgetManager:Ember.inject.service(),click:function(){this._activate()},deactivate:function(){this.set("keyboardActivated",!1)},_activate:function(){this.get("widgetManager").activate(this),this.set("keyboardActivated",!0)}})}),define("dummy/mixins/reset-scroll-position",["exports"],function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.default=Ember.Mixin.create({activate:function(){this._super.apply(this,arguments),"undefined"==typeof FastBoot&&window.scrollTo(0,0)}})}),define("dummy/resolver",["exports","ember-resolver"],function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),e.default=t.default}),define("dummy/router",["exports","dummy/config/environment"],function(e,t){Object.defineProperty(e,"__esModule",{value:!0})
var n=Ember.Router.extend({location:t.default.locationType,rootURL:t.default.rootURL})
n.map(function(){this.route("test-scenario"),this.route("mixins"),this.route("priority"),this.route("usage"),this.route("testing")}),e.default=n}),define("dummy/routes/index",["exports","dummy/mixins/reset-scroll-position"],function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),e.default=Ember.Route.extend(t.default)}),define("dummy/routes/mixins",["exports","dummy/mixins/reset-scroll-position"],function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),e.default=Ember.Route.extend(t.default)}),define("dummy/routes/priority",["exports","dummy/mixins/reset-scroll-position"],function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),e.default=Ember.Route.extend(t.default)}),define("dummy/routes/testing",["exports","dummy/mixins/reset-scroll-position"],function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),e.default=Ember.Route.extend(t.default)}),define("dummy/routes/usage",["exports","dummy/mixins/reset-scroll-position"],function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),e.default=Ember.Route.extend(t.default)}),define("dummy/services/ajax",["exports","ember-ajax/services/ajax"],function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),Object.defineProperty(e,"default",{enumerable:!0,get:function(){return t.default}})}),define("dummy/services/keyboard",["exports","ember-keyboard/services/keyboard"],function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),Object.defineProperty(e,"default",{enumerable:!0,get:function(){return t.default}})}),define("dummy/services/widget-manager",["exports"],function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.default=Ember.Service.extend({activate:function(e){var t=this.get("activeWidget")
t&&!Ember.isEqual(e,t)&&t.deactivate(),this.set("activeWidget",e)}})}),define("dummy/templates/application",["exports"],function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.default=Ember.HTMLBars.template({id:"HBKUOdDU",block:'{"symbols":[],"statements":[[6,"div"],[9,"class","container"],[7],[0,"\\n  "],[6,"nav"],[9,"class","menu"],[7],[0,"\\n    "],[4,"link-to",["index"],null,{"statements":[[0,"Overview"]],"parameters":[]},null],[0,"\\n    "],[4,"link-to",["usage"],null,{"statements":[[0,"Usage"]],"parameters":[]},null],[0,"\\n    "],[4,"link-to",["priority"],null,{"statements":[[0,"Priority"]],"parameters":[]},null],[0,"\\n    "],[4,"link-to",["mixins"],null,{"statements":[[0,"Mixins"]],"parameters":[]},null],[0,"\\n    "],[4,"link-to",["testing"],null,{"statements":[[0,"Testing"]],"parameters":[]},null],[0,"\\n  "],[8],[0,"\\n  "],[6,"div"],[9,"class","main"],[7],[0,"\\n    "],[6,"div"],[9,"class","header"],[7],[0,"\\n      "],[6,"h1"],[7],[0,"\\n        "],[6,"code"],[7],[0,"ember-keyboard"],[8],[0,"\\n      "],[8],[0,"\\n      "],[6,"a"],[9,"href","https://github.com/patience-tema-baron/ember-keyboard"],[9,"target","_blank"],[9,"class","github"],[7],[0,"\\n        "],[6,"img"],[9,"src","./octocat-438c17272c5f0e9f4a6da34d3e4bc5bd.png"],[9,"class","octocat"],[7],[8],[0,"\\n      "],[8],[0,"\\n    "],[8],[0,"\\n    "],[1,[18,"outlet"],false],[0,"\\n  "],[8],[0,"\\n"],[8],[0,"\\n"]],"hasEval":false}',meta:{moduleName:"dummy/templates/application.hbs"}})}),define("dummy/templates/components/key-down-counter",["exports"],function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.default=Ember.HTMLBars.template({id:"1+6hA7GT",block:'{"symbols":[],"statements":[[4,"if",[[20,["priorityInput"]]],null,{"statements":[[0,"  "],[6,"label"],[7],[6,"code"],[7],[0,"keyboardPriority"],[8],[0,":"],[8],[0,"\\n  "],[1,[25,"input",null,[["value","classNames","hook"],[[20,["keyboardPriority"]],"input-field","counter-priority-input"]]],false],[0,"\\n"]],"parameters":[]},null],[0,"\\n"],[4,"if",[[20,["activatedToggle"]]],null,{"statements":[[0,"  "],[6,"label"],[7],[6,"code"],[7],[0,"keyboardActivated"],[8],[0,":"],[8],[0,"\\n  "],[1,[25,"input",null,[["type","checked","classNames","hook"],["checkbox",[20,["toggleActivated"]],"checkbox","counter-activated-toggle"]]],false],[0,"\\n"]],"parameters":[]},null],[0,"\\n"],[4,"if",[[20,["firstResponderToggle"]]],null,{"statements":[[0,"  "],[6,"label"],[7],[6,"code"],[7],[0,"keyboardFirstResponder"],[8],[0,":"],[8],[0,"\\n  "],[1,[25,"input",null,[["type","checked","classNames","hook"],["checkbox",[20,["keyboardFirstResponder"]],"checkbox","counter-first-responder-toggle"]]],false],[0,"\\n"]],"parameters":[]},null],[0,"\\n"],[4,"if",[[20,["laxPriorityToggle"]]],null,{"statements":[[0,"  "],[6,"label"],[7],[6,"code"],[7],[0,"keyboardLaxPriority"],[8],[0,":"],[8],[0,"\\n  "],[1,[25,"input",null,[["type","checked","classNames","hook"],["checkbox",[20,["keyboardLaxPriority"]],"checkbox","counter-lax-priority-toggle"]]],false],[0,"\\n"]],"parameters":[]},null],[0,"\\n"],[4,"if",[[20,["stopImmediatePropagationToggle"]]],null,{"statements":[[0,"  "],[6,"label"],[7],[6,"code"],[7],[0,"stopImmediatePropagation()"],[8],[0,":"],[8],[0,"\\n  "],[1,[25,"input",null,[["type","checked","classNames","hook"],["checkbox",[20,["stopImmediatePropagation"]],"checkbox","counter-stop-immediate-propagation-toggle"]]],false],[0,"\\n"]],"parameters":[]},null],[0,"\\n"],[4,"if",[[20,["stopPropagationToggle"]]],null,{"statements":[[0,"  "],[6,"label"],[7],[6,"code"],[7],[0,"stopPropagation()"],[8],[0,":"],[8],[0,"\\n  "],[1,[25,"input",null,[["type","checked","classNames","hook"],["checkbox",[20,["stopPropagation"]],"checkbox","counter-stop-propagation-toggle"]]],false],[0,"\\n"]],"parameters":[]},null],[0,"\\n"],[6,"div"],[10,"data-test",[25,"hook",["counter-counter"],null],null],[7],[1,[18,"counter"],false],[8],[0,"\\n"]],"hasEval":false}',meta:{moduleName:"dummy/templates/components/key-down-counter.hbs"}})})
define("dummy/templates/components/keyboard-activated-widget",["exports"],function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.default=Ember.HTMLBars.template({id:"Vvba+8kj",block:'{"symbols":[],"statements":[[1,[25,"format-markdown",["\\n## `keyboardActivated`\\n\\nOnce you\'ve included the `EKMixin`, you can activate and deactivate a component\'s keyboard responders by toggling the `keyboardActivated` property. In the examples below, you can toggle each counter\'s `keyboardActivated`:\\n"],null],false],[0,"\\n\\n"],[1,[25,"key-down-counter",null,[["parentActivated","activatedToggle"],[[20,["keyboardActivated"]],true]]],false],[0,"\\n"],[1,[25,"key-down-counter",null,[["parentActivated","activatedToggle"],[[20,["keyboardActivated"]],true]]],false],[0,"\\n"],[1,[25,"key-down-counter",null,[["parentActivated","activatedToggle"],[[20,["keyboardActivated"]],true]]],false],[0,"\\n"]],"hasEval":false}',meta:{moduleName:"dummy/templates/components/keyboard-activated-widget.hbs"}})}),define("dummy/templates/components/keyboard-first-responder-widget",["exports"],function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.default=Ember.HTMLBars.template({id:"EZZ2qeru",block:'{"symbols":[],"statements":[[1,[25,"format-markdown",["\\n### `keyboardFirstResponder`\\n\\nSometimes you\'ll need a component to be the first responder, regardless of its `keyboardPriority` relative to other components. This can be useful if you want a low-priority component to temporarily gain precedence over everything else. To achieve this, use `keyboardFirstResponder`.\\n\\n```hbs\\n{{my-component keyboardPriority=0 keyboardFirstResponder=true}} \x3c!-- has precedence --\x3e\\n{{my-component keyboardPriority=1}}\\n```\\n\\nWhen a component resigns `keyboardFirstResponder`, it will fall back to using its `keyboardPriority`.\\n"],null],false],[0,"\\n\\n"],[1,[25,"key-down-counter",null,[["parentActivated","priorityInput","activatedToggle","firstResponderToggle","keyboardPriority"],[[20,["keyboardActivated"]],true,true,true,1]]],false],[0,"\\n"],[1,[25,"key-down-counter",null,[["parentActivated","priorityInput","activatedToggle","firstResponderToggle","keyboardFirstResponder"],[[20,["keyboardActivated"]],true,true,true,true]]],false],[0,"\\n"],[1,[25,"key-down-counter",null,[["parentActivated","priorityInput","activatedToggle","firstResponderToggle"],[[20,["keyboardActivated"]],true,true,true]]],false],[0,"\\n"]],"hasEval":false}',meta:{moduleName:"dummy/templates/components/keyboard-first-responder-widget.hbs"}})}),define("dummy/templates/components/keyboard-lax-priority-widget",["exports"],function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.default=Ember.HTMLBars.template({id:"Z/fYoDlF",block:'{"symbols":[],"statements":[[1,[25,"format-markdown",["\\n### `keyboardLaxPriority`\\n\\nBy setting `keyboardLaxPriority` to `true`, you\'re saying that it will not block lower priority responders. This can help if you want a group of high level responders to always get a chance to handle key events without blocking the rest of your app. Note that all components within a given priority must have `keyboardLaxPriority` set to `true` or else the priority level will still block, as per usual.\\n"],null],false],[0,"\\n\\n"],[1,[25,"key-down-counter",null,[["parentActivated","priorityInput","activatedToggle","firstResponderToggle","laxPriorityToggle","keyboardPriority","hook"],[[20,["keyboardActivated"]],true,true,true,true,1,"lax-priority-counter"]]],false],[0,"\\n"],[1,[25,"key-down-counter",null,[["parentActivated","priorityInput","activatedToggle","firstResponderToggle","laxPriorityToggle","keyboardFirstResponder","keyboardLaxPriority","hook"],[[20,["keyboardActivated"]],true,true,true,true,true,true,"lax-priority-counter"]]],false],[0,"\\n"],[1,[25,"key-down-counter",null,[["parentActivated","priorityInput","activatedToggle","firstResponderToggle","laxPriorityToggle","hook"],[[20,["keyboardActivated"]],true,true,true,true,"lax-priority-counter"]]],false],[0,"\\n"]],"hasEval":false}',meta:{moduleName:"dummy/templates/components/keyboard-lax-priority-widget.hbs"}})}),define("dummy/templates/components/keyboard-priority-widget",["exports"],function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.default=Ember.HTMLBars.template({id:"S0SiQJ4P",block:'{"symbols":[],"statements":[[1,[25,"format-markdown",["\\n### `keyboardPriority`\\n\\nBy default, all activated components are treated as equal. If you have two components that respond to `ctrl+KeyA`, then both will respond when there\'s a `ctrl+KeyA` event. However, this behavior is undesirable in some scenarios. What if you have a modal open, and you only want it and its child components to respond to key events. You can get this behavior by assigning a higher priority to the modal and its children:\\n\\n```hbs\\nnoPriorityComponent; // priority defaults to 0\\nlowPriorityComponent.set(\'keyboardPriority\', 0);\\n\\nmodal.set(\'keyboardPriority\', 1);\\nmodalChild.set(\'keyboardPriority\', 1);\\n```\\n\\nIn this scenario, when a key is pressed both `modal` and `modalChild` will have a chance to respond to it, while the remaining components will not. Once `modal` and `modalChild` are deactivated or their priority is lowered, then `lowPriorityComponent` and `noPriorityComponent` will be able to respond to key events.\\n\\nPerhaps more conveniently, this property can be passed in through your template:\\n\\n```hbs\\n{{my-component keyboardPriority=1}}\\n{{my-dynamic-component keyboardPriority=dynamicPriority}}\\n```\\n"],null],false],[0,"\\n\\n"],[1,[25,"key-down-counter",null,[["parentActivated","priorityInput","activatedToggle","keyboardPriority"],[[20,["keyboardActivated"]],true,true,1]]],false],[0,"\\n"],[1,[25,"key-down-counter",null,[["parentActivated","priorityInput","activatedToggle"],[[20,["keyboardActivated"]],true,true]]],false],[0,"\\n"],[1,[25,"key-down-counter",null,[["parentActivated","priorityInput","activatedToggle"],[[20,["keyboardActivated"]],true,true]]],false],[0,"\\n"]],"hasEval":false}',meta:{moduleName:"dummy/templates/components/keyboard-priority-widget.hbs"}})}),define("dummy/templates/components/keyboard-propagation-widget",["exports"],function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.default=Ember.HTMLBars.template({id:"0N3DwjJ8",block:'{"symbols":[],"statements":[[1,[25,"format-markdown",["\\n### Event propagation\\n\\nBy setting `emberKeyboard.propagation` in the `config/environment.js` to `true`,\\nyou\'re opting into the new event propagation semantics that were introduced in\\n[issue #63](https://github.com/patience-tema-baron/ember-keyboard/issues/63).\\n\\nThe event propagation is designed to mirror how standard DOM events bubble up\\nthe parent node chain and supports calling a\\n[`stopPropagation()` method](https://developer.mozilla.org/en-US/docs/Web/API/Event/stopPropagation)\\nand\\n[`stopImmediatePropagation()` method](https://developer.mozilla.org/en-US/docs/Web/API/Event/stopImmediatePropagation)\\non a second event object pased to your handlers.\\n\\n```js\\nincrementCounter: on(keyDown(\'RightArrow\'), function(event, ekEvent) {\\n  const key = getCode(event); // => \'RightArrow\'\\n  // ekEvent.stopPropagation();\\n  // ekEvent.stopImmediatePropagation();\\n})\\n```\\n\\nInstead of traversing up the parent node chain, `ember-keyboard` walks down the\\npriority list. This means that all responders with `keyboardFirstResponder` set\\nto `true` will be called first in descending order of their `keyboardPriority`,\\nfollowed by all normal responders in descending order of their `keyboardPriority`.\\n\\nCalling `stopPropagation()` during the first responder phase will allow all\\nfirst responders to get triggered, but will prevent all normal responder to get\\ntriggered.\\n\\nIf you call `stopImmediatePropagation()` during that phase, all following first\\nresponders that have not been triggered yet will be skipped. Event propagation\\nthen continues with the normal responders.\\n\\nYou may call both methods.\\n\\nCalling `stopPropagation()` during the normal responder phase will allow all\\nresponders of the same priority level to get triggered. Lower priority\\nresponders will not get triggered.\\n\\nCalling `stopImmediatePropagation()` during that phase will prevent all\\nresponders of the same priority level that have not been triggered yet from\\ngetting triggered. Event propagation then continues with the next lower priority\\nlevel responders.\\n\\nAgain, you may call both methods.\\n\\nSetting `keyboardLaxPriority` will have no effect, since the semantics are\\nfundamentally incompatible. The major advantage of the new event propagation is,\\nthat higher priority responders get to decide on a per-event basis which events\\nto \'catch\' and which not as opposed to setting or not setting\\n`keyboardLaxPriority` which either \'catches\' no or all events.\\n"],null],false],[0,"\\n\\n"],[1,[25,"key-down-counter",null,[["parentActivated","priorityInput","activatedToggle","firstResponderToggle","stopImmediatePropagationToggle","stopPropagationToggle","keyboardPriority","keyboardFirstResponder","stopImmediatePropagation","hook"],[[20,["keyboardActivated"]],true,true,true,true,true,2,true,true,"propagation-counter"]]],false],[0,"\\n"],[1,[25,"key-down-counter",null,[["parentActivated","priorityInput","activatedToggle","firstResponderToggle","stopImmediatePropagationToggle","stopPropagationToggle","keyboardPriority","keyboardFirstResponder","stopPropagation","hook"],[[20,["keyboardActivated"]],true,true,true,true,true,1,true,true,"propagation-counter"]]],false],[0,"\\n"],[1,[25,"key-down-counter",null,[["parentActivated","priorityInput","activatedToggle","firstResponderToggle","stopImmediatePropagationToggle","stopPropagationToggle","hook"],[[20,["keyboardActivated"]],true,true,true,true,true,"propagation-counter"]]],false],[0,"\\n"]],"hasEval":false}',meta:{moduleName:"dummy/templates/components/keyboard-propagation-widget.hbs"}})}),define("dummy/templates/components/mouse-down-counter",["exports"],function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.default=Ember.HTMLBars.template({id:"FGMbNQ7P",block:'{"symbols":[],"statements":[[6,"div"],[10,"data-test",[25,"hook",["mouse-counter-counter"],null],null],[7],[1,[18,"counter"],false],[8],[0,"\\n"]],"hasEval":false}',meta:{moduleName:"dummy/templates/components/mouse-down-counter.hbs"}})}),define("dummy/templates/components/touch-start-counter",["exports"],function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.default=Ember.HTMLBars.template({id:"YzbKmj0/",block:'{"symbols":[],"statements":[[6,"div"],[10,"data-test",[25,"hook",["touch-counter-counter"],null],null],[7],[1,[18,"counter"],false],[8],[0,"\\n"]],"hasEval":false}',meta:{moduleName:"dummy/templates/components/touch-start-counter.hbs"}})}),define("dummy/templates/components/trigger-event-test",["exports"],function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.default=Ember.HTMLBars.template({id:"RnfVD5AG",block:'{"symbols":[],"statements":[[6,"div"],[10,"data-test",[25,"hook",["key_down"],null],null],[7],[1,[18,"keyDown"],false],[8],[0,"\\n"],[6,"div"],[10,"data-test",[25,"hook",["key_down_with_mods"],null],null],[7],[1,[18,"keyDownWithMods"],false],[8],[0,"\\n"],[6,"div"],[10,"data-test",[25,"hook",["key_press"],null],null],[7],[1,[18,"keyPress"],false],[8],[0,"\\n"],[6,"div"],[10,"data-test",[25,"hook",["key_up"],null],null],[7],[1,[18,"keyUp"],false],[8],[0,"\\n"]],"hasEval":false}',meta:{moduleName:"dummy/templates/components/trigger-event-test.hbs"}})}),define("dummy/templates/index",["exports"],function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.default=Ember.HTMLBars.template({id:"7KvHPWyJ",block:'{"symbols":[],"statements":[[1,[25,"format-markdown",["\\n## Installation\\n\\n`ember install ember-keyboard`\\n\\n## Overview\\n\\n`ember-keyboard` is a KeyboardEvent manager for Ember.js. It provides a simple API for responding to key events based on the [code property](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code), and it automatically applies a polyfill for browsers that do not yet support it.\\n\\nFor more complex scenarios, `ember-keyboard` also offers an API for managing which components and routes respond to key events, allowing you to control for application states such as modals and loading screens.\\n"],null],false],[0,"\\n"]],"hasEval":false}',meta:{moduleName:"dummy/templates/index.hbs"}})}),define("dummy/templates/mixins",["exports"],function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.default=Ember.HTMLBars.template({id:"5HQmLsvl",block:'{"symbols":[],"statements":[[1,[25,"format-markdown",["\\n## Mixins\\n\\nTo reduce boilerplate, `ember-keyboard` includes several mixins with common patterns.\\n\\n**Note: these are used alongside `EKMixin`, it must be included as well for these to work.**\\n\\n### EKOnInsertMixin\\n\\n`import { EKOnInsertMixin } from \'ember-keyboard\';`\\n\\nThis mixin will activate the component on `didInsertElement`, and as per normal, it will deactivate on `willDestroyElement`.\\n\\n### EKOnInitMixin\\n\\n`import { EKOnInitMixin } from \'ember-keyboard\';`\\n\\nThis mixin will activate the controller on `init`.\\n\\n### EKOnFocusMixin\\n\\n`import { EKOnFocusMixin } from \'ember-keyboard\';`\\n\\nThis mixin will activate the component whenever it receives focus and deactivate it when it loses focus.\\n\\n### EKFirstResponderOnFocusMixin\\n\\n`import { EKFirstResponderOnFocusMixin } from \'ember-keyboard\';`\\n\\nThis mixin grants the component first responder status while it is focused. When it loses focus, it resigns its status.\\n\\nNote that it will also activate the component on focus in, though it does not deactivate the component on focus out.\\n"],null],false],[0,"\\n"]],"hasEval":false}',meta:{moduleName:"dummy/templates/mixins.hbs"}})}),define("dummy/templates/priority",["exports"],function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.default=Ember.HTMLBars.template({id:"HDHlB/6z",block:'{"symbols":[],"statements":[[1,[25,"format-markdown",["\\n## Priority\\n\\nBelow are several interactive demos of `ember-keyboard` properties. They allow you to see how different properties interact with each other. Simply click the containing box and try using the below key commands.\\n\\nControls:\\n\\n* `LeftArrow`: decrement counter by 1\\n* `RightArrow`: increment counter by 1\\n* `shift`+ArrowKey: increment/decrement x10\\n* `ctrl+shift`+ArrowKey: increment/decrement x100\\n* `r`: resets counter to 0\\n"],null],false],[0,"\\n\\n"],[1,[18,"keyboard-activated-widget"],false],[0,"\\n\\n"],[1,[18,"keyboard-priority-widget"],false],[0,"\\n\\n"],[1,[18,"keyboard-first-responder-widget"],false],[0,"\\n\\n"],[1,[18,"keyboard-lax-priority-widget"],false],[0,"\\n\\n"],[1,[18,"keyboard-propagation-widget"],false],[0,"\\n"]],"hasEval":false}',meta:{moduleName:"dummy/templates/priority.hbs"}})}),define("dummy/templates/test-scenario",["exports"],function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.default=Ember.HTMLBars.template({id:"hujaUUO/",block:'{"symbols":[],"statements":[[1,[25,"key-down-counter",null,[["parentActivated","priorityInput","activatedToggle","firstResponderToggle","laxPriorityToggle","stopImmediatePropagationToggle","stopPropagationToggle"],[true,true,true,true,true,true,true]]],false],[0,"\\n"],[1,[25,"key-down-counter",null,[["parentActivated","priorityInput","activatedToggle","firstResponderToggle","laxPriorityToggle","stopImmediatePropagationToggle","stopPropagationToggle"],[true,true,true,true,true,true,true]]],false],[0,"\\n"],[1,[25,"key-down-counter",null,[["parentActivated","priorityInput","activatedToggle","firstResponderToggle","laxPriorityToggle","stopImmediatePropagationToggle","stopPropagationToggle"],[true,true,true,true,true,true,true]]],false],[0,"\\n"],[1,[25,"mouse-down-counter",null,[["parentActivated","priorityInput","activatedToggle","firstResponderToggle","laxPriorityToggle","stopImmediatePropagationToggle","stopPropagationToggle"],[true,true,true,true,true,true,true]]],false],[0,"\\n"],[1,[25,"touch-start-counter",null,[["parentActivated","priorityInput","activatedToggle","firstResponderToggle","laxPriorityToggle","stopImmediatePropagationToggle","stopPropagationToggle"],[true,true,true,true,true,true,true]]],false],[0,"\\n"]],"hasEval":false}',meta:{moduleName:"dummy/templates/test-scenario.hbs"}})}),define("dummy/templates/testing",["exports"],function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.default=Ember.HTMLBars.template({id:"/8WLdNpv",block:"{\"symbols\":[],\"statements\":[[1,[25,\"format-markdown\",[\"\\n## Testing\\n\\n### Integration Testing\\n\\nSince integration tests do not run initializers, you'll need to manually run the `ember-keyboard` initializer before each test:\\n\\n```js\\nimport { initialize } from 'ember-keyboard';\\n\\nmoduleForComponent('my component', 'Integration | Component | my component', {\\n  integration: true,\\n\\n  beforeEach() {\\n    initialize();\\n  }\\n});\\n```\\n\\n### Trigger Key Events\\n\\nIf you need to manually trigger a key event (such as in a component integration test), you can use `triggerKeyDown`, `triggerKeyPress`, and `triggerKeyUp`. By default, the event triggers on the `document`, but you can optionally provide a DOM element as the second argument:\\n\\n```js\\nimport { triggerKeyDown, triggerKeyPress, triggerKeyUp } from 'ember-keyboard';\\n\\n. . . .\\n\\ntest('test my key bindings', function(assert) {\\n  triggerKeyDown('KeyA'); // triggers on `document`\\n  triggerKeyUp('KeyA+shift+cmd', document.getElementById('foo')); // triggers on `#foo`\\n});\\n```\\n\\n### Async Acceptance Test Helpers\\n\\n`ember-keyboard` comes with some test helpers to help out with your acceptance tests.\\n\\n```js\\n. . . .\\n\\ntest('test my key bindings', function(assert) {\\n  . . . .\\n\\n  keyUp('ArrowRight'); // triggers on document\\n\\n  andThen(() => {\\n    . . . .\\n  });\\n\\n  keyDown('ArrowRight+ctrl+shift', document.getElementById('foo')); // triggers on `#foo`\\n\\n  andThen(() => {\\n    . . . .\\n  });\\n});\\n```\\n\\nTo use them, you'll need to import them into `tests/helpers/start-app.js` above `application.injectTestHelpers()`:\\n\\n```js\\n. . . .\\nimport keyboardRegisterTestHelpers from './ember-keyboard/register-test-helpers';\\n\\nexport default function startApp(attrs) {\\n  . . . .\\n\\n  Ember.run(function() {\\n    . . . .\\n    keyboardRegisterTestHelpers();\\n    application.injectTestHelpers();\\n  });\\n\\n  . . . .\\n}\\n```\\n\"],null],false],[0,\"\\n\"]],\"hasEval\":false}",meta:{moduleName:"dummy/templates/testing.hbs"}})}),define("dummy/templates/usage",["exports"],function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.default=Ember.HTMLBars.template({id:"oAe8t68N",block:"{\"symbols\":[],\"statements\":[[1,[25,\"format-markdown\",[\"\\n## Usage\\n\\nFirst, add `EKMixin` to a component or route:\\n\\n```js\\nimport Ember from 'ember';\\nimport { EKMixin } from 'ember-keyboard';\\n\\nexport default Ember.Component.extend(EKMixin, {\\n  . . . .\\n});\\n```\\n\\nNow this component observes several new properties that'll help it determine when and if it should respond to key events. These properties are outlined in greater detail below, but to simply get things started, you'll need to set `keyboardActivated` to true:\\n\\n```js\\n  activateKeyboard: Ember.on('init', function() {\\n    this.set('keyboardActivated', true);\\n  })\\n```\\n\\nOr simply activate the component from your template:\\n\\n```hbs\\n{{my-component keyboardActivated=true}}\\n```\\n\\nOnce it's activated, this component will start listening for key events. Let's say you want this component to respond to the key `s` as well as `ctrl+shift+a`. You could do so with:\\n\\n```js\\nimport { keyUp, keyDown } from 'ember-keyboard';\\n\\n. . . .\\n\\naFunction: Ember.on(keyUp('KeyS'), function() {\\n  console.log('`KeyS` was pressed');\\n}),\\n\\nanotherFunction: Ember.on(keyDown('ctrl+shift+KeyA'), function() {\\n  console.log('`ctrl+shift+KeyA` is being held');\\n})\\n```\\n\\n### Modifier Keys\\n\\nAs mentioned above, you can augment your key bindings with modifier keys, including `ctrl`, `shift`, `alt`, and `meta`. In addition, `ember-keyboard` supports a special key definition called `cmd`. It is very common for macOS users to expect to use key combinations such as Command(⌘)+Key, where a PC or Linux user would use Ctrl+Key. `cmd` handles this behavior. For instance this defintion:\\n\\n```js\\ntriggerSubmit: Ember.on(keyDown('Enter+cmd'), function() {\\n  this.submit();\\n});\\n```\\n\\nwill trigger on Command(⌘)+Enter on macOS or Ctrl+Enter on all other platforms.\\n\\nNote that `ctrl` should be used with caution, as MacOSs will swollow some `ctrl` events before `ember-keyboard` can observe them.\\n\\n### `keyUp`, `keyDown`, `keyPress`, `mouseDown`, `mouseUp`, `click`, `touchStart`, and `touchEnd`\\n\\nBy default, `ember-keyboard` listens to `keydown`, `keyup`, and `keypress`. It can optionally listen to `mousedown`, `mouseup`, `click`, `touchstart`, and `touchend` as well. Each has corresponding functions:\\n\\n```js\\nimport { keyUp, keyDown, keyPress, mouseDown, mouseUp, click, touchStart, touchEnd } from 'ember-keyboard';\\n```\\n\\nIf you want `ember-keyboard` to listen to fewer events or to add any of the mouse/touch event, then you can specify them in your `config/environment.js` file like so:\\n\\n```js\\nENV.emberKeyboard = {\\n  listeners: ['keyUp', 'keyDown', 'click'] // use only `keyUp`, `keyDown`, and `click`\\n}\\n```\\n\\nNote that `keydown` events fire repeatedly while the key is pressed, while `keyup` events fire only once, after the key has been released.\\n\\n### Mouse Events\\n\\nMouse events can listen for the `left`, `right`, and `middle` buttons like so:\\n\\n```js\\ntriggerSubmit: Ember.on(mouseUp('left'), function() {\\n  this.submit();\\n});\\n```\\n\\nYou can also combine it with the standard modifier keys:\\n\\n```js\\ntriggerSubmit: Ember.on(mouseUp('left+cmd'), function() {\\n  this.submit();\\n});\\n```\\n\\n### `event`\\n\\nWhen `ember-keyboard` triggers an event, it passes in the `event` object as its first argument:\\n\\n```js\\nsaveDocument: Ember.on(keyDown('ctrl+KeyS'), function(event) {\\n  this.performSave();\\n  event.preventDefault();\\n})\\n```\\n\\nNote that if you want `preventDefault` to prevent `window` level events, you'll need to use `keyDown`, as the default event will fire before `keyUp`.\\n\\n### `getCode`\\n\\nDid you know that 65 was the keycode for 'KeyA'? Or that 37 was the keycode for the right arrow? If you don't want to litter your code with keycode references, you can use `getCode`, which `ember-keyboard` uses internally:\\n\\n```js\\nimport { getCode } from 'ember-keyboard';\\n\\n. . . .\\n\\nkeyMapper: Ember.on(keyDown('KeyA'), keyDown('KeyB'), keyDown('KeyC'), function(event) {\\n  const key = getCode(event);\\n  switch (key) {\\n    match 'KeyA': console.log('It\\\\'s an a!'); break;\\n    . . . .\\n  }\\n})\\n```\\n\\n### `getKeyCode`\\n\\nOn the other end of things, if you need to convert a code into a keycode, you can use `getKeyCode`. This is particularly useful when testing:\\n\\n```js\\nimport { getKeyCode } from 'ember-keyboard';\\n\\n. . . .\\n\\nkeyEvent(document, 'keydown', getKeyCode('KeyA'));\\nkeyEvent(document, 'keydown', getKeyCode('ArrowRight'));\\nkeyEvent(document, 'keydown', getKeyCode('Backspace'));\\nkeyEvent(document, 'keydown', getKeyCode('Space'));\\n```\\n\\nJust pass in an `event`, and it'll return a human readable key. Look [here](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code) for a full mapping.\\n\\n### Key Indifference\\n\\nIf you want an event to fire for every keypress, then simply don't provide a keystring to `keyUp` or `keyDown`. This can be a handy way to trigger events for large ranges of keys, such as on any alphanumeric keypress. For instance:\\n\\n```js\\ntriggerOnAlphaNumeric: Ember.on(keyUp(), function(event) {\\n  if (/^Key\\\\w(?!.)/.test(getCode(event))) {\\n    this.startEditing();\\n  }\\n})\\n```\\n\\n### `Ember.TextField` && `Ember.TextArea`\\n\\nTo prevent `ember-keyboard` from responding to key strokes while an input/textarea is focused, we've reopened `Ember.TextField` and `Ember.TextArea` and applied the `EKOnInsertMixin` and `EKFirstResponderOnFocusMixin`. This ensures that whenever an input is focused, other key responders will not fire. If you want to have responders associated with an input or textarea (such as a rich text editor with `keyUp('ctrl+i')` bindings), you need to extend these components from `Ember.TextField` or `Ember.TextArea` rather than `Ember.component`.\\n\\nThis applies to `input` and `textarea` helpers:\\n\\n```hbs\\n{{input}}\\n{{textarea}}\\n```\\n\\n### Unpropogated Key Events\\n\\nSome key events get swollowed by the browser well before they reach `ember-keyboard`. Here is a growing (aka incomplete) list of such events:\\n\\n* Enter: keyUp (keyDown works)\\n\"],null],false],[0,\"\\n\"]],\"hasEval\":false}",meta:{moduleName:"dummy/templates/usage.hbs"}})}),define("dummy/utils/get-cmd-key",["exports","ember-keyboard/utils/get-cmd-key"],function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),Object.defineProperty(e,"default",{enumerable:!0,get:function(){return t.default}})}),define("dummy/utils/listener-name",["exports","ember-keyboard/utils/listener-name"],function(e,t){Object.defineProperty(e,"__esModule",{value:!0}),Object.defineProperty(e,"default",{enumerable:!0,get:function(){return t.default}})}),define("dummy/config/environment",[],function(){try{var e="dummy/config/environment",t=document.querySelector('meta[name="'+e+'"]').getAttribute("content"),n={default:JSON.parse(unescape(t))}
return Object.defineProperty(n,"__esModule",{value:!0}),n}catch(t){throw new Error('Could not read config from meta tag with name "'+e+'".')}}),runningTests||require("dummy/app").default.create({})
